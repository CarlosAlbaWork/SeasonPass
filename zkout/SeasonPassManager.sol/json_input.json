{
  "language": "Solidity",
  "sources": {
    "src/contracts/SeasonPassManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title Smart Contract that manages a season pass ticket for live events.\n * @author Carlos Alba\n * @notice This contract uses Blockchain technology to manage a Season Pass with different functionality\n *\n */\n\ncontract SeasonPassManager is Ownable {\n    /////////////////////////////////////////////////////////////////////////////////\n    /////////////////////// ERRORS //////////////////////////////////////////////////\n    /////////////////////////////////////////////////////////////////////////////////\n\n    error SeasonPass_CalledInWrongStage();\n    error SeasonPass_FanAddedBefore();\n    error SeasonPass_FanHasNoSeasonPass();\n    error SeasonPass_MaximumFansAdded();\n    error SeasonPass_SeatIsNotFree();\n    error SeasonPass_MaxSeatsInZone();\n    error SeasonPass_WrongInformationGiven();\n    error SeasonPass_MoreSeasonPassesThanExpected(\n        uint256 length,\n        uint256 maxFans\n    );\n    error SeasonPass_NotOwnerOfSeasonPass();\n    error SeasonPass_NotEnoughETHSent();\n\n    /////////////////////////////////////////////////////////////////////////////////\n    /////////////////////// STRUCTS /////////////////////////////////////////////////\n    /////////////////////////////////////////////////////////////////////////////////\n\n    struct Seat {\n        address seatOwner;\n        uint256 zone;\n        uint256 row;\n        uint256 seatId;\n        uint256 rowSeatNumber;\n    }\n\n    struct SeasonPass {\n        uint256 idOfSeasonPass;\n        uint256 seatId;\n        bool[] matchesGoneToStadium;\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////\n    /////////////////////// ENUMS ///////////////////////////////////////////////////\n    /////////////////////////////////////////////////////////////////////////////////\n\n    enum Stages {\n        PRE_CAMPAIGN,\n        RENEWALS,\n        SEAT_CHANGES,\n        NEW_FANS,\n        REGULAR_SEASON\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////\n    /////////////////////// EVENTS //////////////////////////////////////////////////\n    /////////////////////////////////////////////////////////////////////////////////\n\n    event SeasonPass_NumberOfSeatsModified(\n        uint256 indexed oldnumberOfMaxSeats,\n        uint256 indexed newnumberOfMaxSeats\n    );\n    event SeasonPass_UpdatedSeatAvailability();\n    event SeasonPass_UpdatedSympathizerFee(\n        uint256 indexed oldSympathizerFee,\n        uint256 indexed newSympathizerFee\n    );\n    event SeasonPass_NewSeasonStarted(\n        uint256 indexed numberOfMaxFans_,\n        uint256 indexed numberOfMaxSeats_,\n        uint256 indexed numberOfZones_\n    );\n    event SeasonPass_AdvancedTheStage(Stages newstage);\n    event SeasonPass_UpdatedNumberOfSeasonPassIds();\n    event SeasonPass_DeletedOldNumberOfSeasonPassIds();\n    event SeasonPass_SetSeatAvailability();\n    event SeasonPass_NewSympathizer(\n        address indexed sympathizer,\n        uint256 indexed numberOfSympathizers\n    );\n    event SeasonPass_NewFan(address indexed fan, uint256 indexed numberOfFans);\n    event SeasonPass_ChangeSeat(address indexed fan);\n\n    /////////////////////////////////////////////////////////////////////////////////\n    /////////////////////// VARIABLES ///////////////////////////////////////////////\n    /////////////////////////////////////////////////////////////////////////////////\n\n    uint256 private seasonNumber;\n\n    uint256 private numberOfMaxFans;\n    uint256 private numberOfCurrentFans;\n\n    uint256 private numberOfMaxSeats;\n\n    uint256 private numberOfSympathizer; //They have no seat , but have benefits of SeasonPass Holders\n    uint256 private sympathizerFee;\n\n    //If we start giving the sympathizers the ids just after numberOfMaxFans, it can be a problem\n    // if in the future we make greater this number\n    //Example. 12 000 max fans 1st season . 1 000 are sympathizers and we give them ids from 12001 to 13 000\n    //Then if in 2nd season we make the max fans 15 000 , when giving the iDs to new fans , the new 3000 fans will clash\n    //Ids with sympathizer (fan 12 001 wil have same id as sympathizer 1)\n    //Therefore we add an offset to make it barely impossible to add as many new fans\n\n    uint256 private constant SYMPATHIZER_OFFSET = 1000000;\n\n    uint256 private numberOfZones;\n    Stages private seasonStages;\n\n    // Some seats are reserved to sell as one use tickets. Therefore there should be a mapping that controls that this number is never surpassed\n    //Se puede usar para este primero un array\n    mapping(uint256 zone => uint256 availableSeats) s_MaxAvailableSeats;\n    mapping(address fan => SeasonPass) s_SeasonPasses;\n    mapping(uint256 seatId => Seat) s_Seats;\n\n    modifier onlyInGivenStage(Stages stage_, bool possibleAfter_) {\n        if (\n            (seasonStages < stage_ && possibleAfter_) || seasonStages != stage_\n        ) {\n            revert SeasonPass_CalledInWrongStage();\n        }\n        _;\n    }\n\n    constructor(\n        uint256 seasonNumber_,\n        uint256 numberOfMaxFans_,\n        uint256 numberOfMaxSeats_,\n        uint256 numberOfZones_,\n        uint256 sympathizerFee_\n    ) Ownable(msg.sender) {\n        seasonNumber = seasonNumber_;\n        numberOfMaxFans = numberOfMaxFans_;\n        numberOfMaxSeats = numberOfMaxSeats_;\n        numberOfZones = numberOfZones_;\n        sympathizerFee = sympathizerFee_;\n        seasonStages = Stages.RENEWALS;\n    }\n\n    //Function to add or delete seats in case of renovation in stadium or other situations\n    // If isDeleting == true: Just delete the seats\n    //else adding seats or information\n    function setSeatInfo(\n        Seat[] memory seatInfo,\n        bool isDeleting\n    ) external onlyOwner {\n        uint256 oldNumberOfMaxSeats = numberOfMaxSeats;\n        if (isDeleting == true) {\n            for (uint i; i < seatInfo.length; i++) {\n                s_Seats[seatInfo[i].seatId].rowSeatNumber = 0;\n            }\n            numberOfMaxSeats -= seatInfo.length;\n        } else {\n            for (uint i; i < seatInfo.length; i++) {\n                s_Seats[seatInfo[i].seatId] = seatInfo[i];\n            }\n            if (seatInfo.length != numberOfMaxSeats) {\n                numberOfMaxSeats += seatInfo.length;\n            }\n        }\n        emit SeasonPass_NumberOfSeatsModified(\n            oldNumberOfMaxSeats,\n            numberOfMaxSeats\n        );\n    }\n\n    //Always after setSeatInfo, in order to mantain integrity with the mapping of available seats\n\n    function modifyAvailableSeats(\n        int256[] memory variationOfAvailableSeats\n    ) external onlyOwner {\n        for (uint i = 0; i < variationOfAvailableSeats.length; i++) {\n            s_MaxAvailableSeats[i] = uint256(\n                int256(s_MaxAvailableSeats[i]) + variationOfAvailableSeats[i]\n            );\n        }\n        emit SeasonPass_UpdatedSeatAvailability();\n    }\n\n    function setSympathizerFee(uint256 newfee_) external onlyOwner {\n        uint256 oldSympathizerFee = sympathizerFee;\n        sympathizerFee = newfee_;\n        emit SeasonPass_UpdatedSympathizerFee(\n            oldSympathizerFee,\n            sympathizerFee\n        );\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////\n    /////////////////////// STAGE MANAGEMENT ////////////////////////////////////////\n    /////////////////////////////////////////////////////////////////////////////////\n\n    function startNewSeason(\n        uint256 numberOfMaxFans_,\n        uint256 numberOfMaxSeats_,\n        uint256 numberOfZones_\n    ) external onlyOwner {\n        seasonNumber++;\n        numberOfMaxFans = numberOfMaxFans_;\n        numberOfMaxSeats = numberOfMaxSeats_;\n        numberOfZones = numberOfZones_;\n        seasonStages = Stages.RENEWALS;\n        emit SeasonPass_NewSeasonStarted(\n            numberOfMaxFans,\n            numberOfMaxSeats,\n            numberOfZones_\n        );\n    }\n\n    function advanceStage() external onlyOwner {\n        if (seasonStages == Stages.REGULAR_SEASON) {\n            revert SeasonPass_CalledInWrongStage();\n        }\n        seasonStages = Stages(uint256(seasonStages) + 1);\n        emit SeasonPass_AdvancedTheStage(seasonStages);\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////\n    /////////////////////// RENEWALS ////////////////////////////////////////////////\n    /////////////////////////////////////////////////////////////////////////////////\n\n    // array of addresses of fans in order\n    //Once a year normally\n\n    function changeNumberOfSeasonIds(\n        address[] memory fans_\n    ) external onlyOwner onlyInGivenStage(Stages.RENEWALS, false) {\n        if (fans_.length > numberOfMaxFans) {\n            revert SeasonPass_MoreSeasonPassesThanExpected(\n                fans_.length,\n                numberOfMaxFans\n            );\n        }\n        for (uint i; i < fans_.length; i++) {\n            s_SeasonPasses[fans_[i]].idOfSeasonPass = i + 1;\n        }\n        numberOfCurrentFans = fans_.length;\n        emit SeasonPass_UpdatedNumberOfSeasonPassIds();\n    }\n\n    function deleteNumberOfSeasonIds(\n        address[] memory fans_\n    ) external onlyOwner onlyInGivenStage(Stages.RENEWALS, false) {\n        for (uint i = 0; i < fans_.length; i++) {\n            s_SeasonPasses[fans_[i]].idOfSeasonPass = 0;\n            s_SeasonPasses[fans_[i]].seatId = 0;\n        }\n        emit SeasonPass_DeletedOldNumberOfSeasonPassIds();\n    }\n\n    //Different function to deleteNumberOfSeasonIds to count zone available seats\n    function setSeatAvailability(\n        uint256[][] memory freeSeatIds_ //like a mapping(uint256 zone => uint256 availableSeats)\n    ) external onlyOwner onlyInGivenStage(Stages.RENEWALS, false) {\n        for (uint j; j < numberOfZones; j++) {\n            for (uint i = 0; i < freeSeatIds_[j].length; i++) {\n                if (s_Seats[freeSeatIds_[j][i]].seatOwner != address(0)) {\n                    s_Seats[freeSeatIds_[j][i]].seatOwner = address(0);\n                }\n            }\n            s_MaxAvailableSeats[j] = freeSeatIds_[j].length;\n            emit SeasonPass_SetSeatAvailability();\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////\n    /////////////////////// SEAT_CHANGES ////////////////////////////////////////////\n    /////////////////////////////////////////////////////////////////////////////////\n\n    //It will be executed in any other stage that is not RENEWALS\n\n    function changeSeat(\n        address fanAddress_,\n        uint256 oldSeatId_,\n        uint256 oldZoneId_,\n        uint256 newSeatId_,\n        uint256 newZoneId_\n    ) external onlyOwner onlyInGivenStage(Stages.SEAT_CHANGES, true) {\n        if (s_SeasonPasses[fanAddress_].seatId == 0) {\n            revert SeasonPass_FanHasNoSeasonPass();\n        }\n        if (s_Seats[newSeatId_].seatOwner != address(0)) {\n            revert SeasonPass_SeatIsNotFree();\n        }\n        if (s_MaxAvailableSeats[newZoneId_] == 0) {\n            revert SeasonPass_MaxSeatsInZone();\n        }\n        if (\n            s_Seats[s_SeasonPasses[fanAddress_].seatId].zone != oldZoneId_ ||\n            s_SeasonPasses[fanAddress_].seatId != oldSeatId_\n        ) {\n            revert SeasonPass_WrongInformationGiven();\n        }\n        s_Seats[oldSeatId_].seatOwner = address(0);\n        s_MaxAvailableSeats[oldZoneId_]++;\n        s_Seats[newSeatId_].seatOwner = fanAddress_;\n        s_MaxAvailableSeats[newZoneId_]--;\n        s_SeasonPasses[fanAddress_].seatId = newSeatId_;\n        emit SeasonPass_ChangeSeat(fanAddress_);\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////\n    /////////////////////// NEW_FANS ////////////////////////////////////////////////\n    /////////////////////////////////////////////////////////////////////////////////\n\n    function becomeSympathizer()\n        external\n        payable\n        onlyInGivenStage(Stages.NEW_FANS, true)\n    {\n        if (\n            s_SeasonPasses[msg.sender].seatId != 0 ||\n            s_SeasonPasses[msg.sender].idOfSeasonPass != 0\n        ) {\n            revert SeasonPass_FanAddedBefore();\n        }\n\n        if (msg.value < sympathizerFee) {\n            revert SeasonPass_NotEnoughETHSent();\n        }\n\n        s_SeasonPasses[msg.sender].idOfSeasonPass =\n            seasonNumber *\n            SYMPATHIZER_OFFSET +\n            numberOfSympathizer +\n            1;\n        numberOfSympathizer++;\n        emit SeasonPass_NewSympathizer(msg.sender, numberOfSympathizer);\n    }\n\n    function addNewFan(\n        address fan_,\n        uint256 seatId_,\n        uint256 zone_\n    ) external onlyOwner onlyInGivenStage(Stages.NEW_FANS, true) {\n        if (s_SeasonPasses[fan_].seatId != 0) {\n            revert SeasonPass_FanAddedBefore();\n        }\n        if (s_Seats[seatId_].seatOwner != address(0)) {\n            revert SeasonPass_SeatIsNotFree();\n        }\n        if (s_MaxAvailableSeats[zone_] == 0) {\n            revert SeasonPass_MaxSeatsInZone();\n        }\n        if (numberOfCurrentFans >= numberOfMaxFans) {\n            revert SeasonPass_MaximumFansAdded();\n        }\n\n        s_Seats[seatId_].seatOwner = fan_;\n\n        SeasonPass memory newSeasonPass;\n        newSeasonPass.idOfSeasonPass = numberOfCurrentFans;\n        newSeasonPass.seatId = seatId_;\n\n        s_SeasonPasses[fan_] = newSeasonPass;\n        s_MaxAvailableSeats[zone_]--;\n        numberOfCurrentFans++;\n        emit SeasonPass_NewFan(fan_, numberOfCurrentFans);\n    }\n\n    //Si es la primera jornada, es posible que con un carnet se entre varias veces por como está hecho el código. Hay que poner un check en el Front\n    function attendMatch(\n        uint256 match_,\n        address fan_\n    ) external onlyOwner returns (bool) {\n        bool[] memory aux = s_SeasonPasses[fan_].matchesGoneToStadium;\n        if (!aux[match_] || (match_ == 1 && aux[0] != isEven(seasonNumber))) {\n            if (match_ == 1) {\n                aux[1] = true;\n                aux[0] = isEven(seasonNumber);\n                s_SeasonPasses[fan_].matchesGoneToStadium = aux;\n            } else {\n                s_SeasonPasses[fan_].matchesGoneToStadium[match_] = true;\n            }\n            return true;\n        }\n        return false;\n    }\n\n    function isEven(uint256 seasonNumber_) public pure returns (bool) {\n        if (seasonNumber_ % 2 == 0) {\n            return true;\n        }\n        return false;\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////\n    /////////////////////// GETTERS /////////////////////////////////////////////////\n    /////////////////////////////////////////////////////////////////////////////////\n\n    function getNumberOfSympathizer() public view returns (uint256) {\n        return numberOfSympathizer;\n    }\n\n    function getSeasonNumber() public view returns (uint256) {\n        return seasonNumber;\n    }\n\n    function getSympathizerFee() public view returns (uint256) {\n        return sympathizerFee;\n    }\n\n    function getNumberOfMaxFans() public view returns (uint256) {\n        return numberOfMaxFans;\n    }\n\n    function getNumberOfCurrentFans() public view returns (uint256) {\n        return numberOfCurrentFans;\n    }\n\n    function getNumberOfMaxSeats() public view returns (uint256) {\n        return numberOfMaxSeats;\n    }\n\n    function getNumberOfZones() public view returns (uint256) {\n        return numberOfZones;\n    }\n\n    function getSeasonStages() public view returns (Stages) {\n        return seasonStages;\n    }\n\n    // Getter function for s_MaxAvailableSeats\n    function getMaxAvailableSeats(uint256 zone) public view returns (uint256) {\n        return s_MaxAvailableSeats[zone];\n    }\n\n    // Getter function for s_SeasonPasses\n    function getSeasonPass(\n        address fan\n    ) public view returns (SeasonPass memory) {\n        return s_SeasonPasses[fan];\n    }\n\n    // Getter function for s_Seats\n    function getSeat(uint256 seatId) public view returns (Seat memory) {\n        return s_Seats[seatId];\n    }\n\n    function getSeatOwner(uint256 seatId) public view returns (address) {\n        return s_Seats[seatId].seatOwner;\n    }\n\n    function getSeatOfFan(address fan_) public view returns (uint256) {\n        //MIght have to restrict to msg.sender == fan_ or Owner\n        return s_SeasonPasses[fan_].seatId;\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/",
      "@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/",
      "ds-test/=lib/openzeppelin-contracts/lib/forge-std/lib/ds-test/src/",
      "erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/",
      "forge-std/=lib/forge-std/src/",
      "openzeppelin-contracts/=lib/openzeppelin-contracts/"
    ],
    "optimizer": {
      "enabled": true,
      "mode": "3",
      "details": null,
      "fallbackToOptimizingForSize": false,
      "disableSystemRequestMemoization": true
    },
    "outputSelection": {
      "*": {
        "": [
          "metadata"
        ],
        "*": [
          "abi",
          "evm.methodIdentifiers"
        ]
      }
    },
    "libraries": {},
    "isSystem": false,
    "forceEvmla": false,
    "areLibrariesMissing": false
  }
}